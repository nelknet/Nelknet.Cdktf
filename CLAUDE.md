# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an F# Infrastructure-as-Code DSL that wraps the CDK for Terraform (CDKTF). It provides computation expressions for defining Terraform infrastructure with strong typing and ergonomic F# syntax, similar to Pulumi.FSharp.Extensions but targeting Terraform providers.

## Common Development Commands

### Building and Running
```bash
# Install local Node dependencies and generate providers
npm install
dotnet build -p:ForceCodeGen=true

# Subsequent builds
dotnet build

# Run the Hetzner example (requires HCLOUD_TOKEN)
HCLOUD_TOKEN=your-token dotnet run --project examples/Nelknet.Cdktf.Examples

# Synthesize Terraform configuration to cdktf.out/
HCLOUD_TOKEN=your-token cdktf synth

# Deploy to Hetzner (requires valid token)
HCLOUD_TOKEN=your-token cdktf deploy

# Show what would change without applying
HCLOUD_TOKEN=your-token cdktf diff
```

### Provider Management
```bash
# After editing cdktf.json, scaffold any missing provider projects
dotnet fsi tools/scaffold-providers.fsx

# Regenerate bindings (C# + F#)
dotnet build -p:ForceCodeGen=true
```

## Architecture & Key Design Patterns

### Stack Context Pattern
The `stack { }` computation expression manages CDKTF App/Stack lifecycle using `AsyncLocal<TerraformStack>` to provide ambient context. This eliminates explicit stack parameter passing to nested builders.

```fsharp
// Entry point - creates App and Stack, sets ambient context
stack "my-stack" {
    // All nested builders access stack via StackContext.get()
    let provider = Hcloud.provider "hcloud" { ... }
    let server = Hcloud.server "web" { ... }
}
```

### Computation Expression Builders
Each resource type has a dedicated builder with custom operations that mirror Terraform schema field names:

- `StackBuilder` in `Core.fs` - Top-level stack management
- `ProviderBuilder` in `HcloudDsl.fs` - Provider configuration (token, poll_interval)
- `ServerBuilder` in `HcloudDsl.fs` - Server resource (name, server_type, image, labels)
- `OutputBuilder` in `TerraformOutputs.fs` - Terraform outputs (value, description, sensitive)

Custom operations use snake_case to match Terraform schema conventions.

### Provider Bindings Architecture
```
F# DSL core (src/Core/Nelknet.Cdktf.Core/)
    ↓ wraps
Generated C# bindings (generated/hcloud/)
    ↓ uses
CDKTF base classes (HashiCorp.Cdktf)
    ↓ via JSII Runtime
TypeScript CDKTF core
    ↓ synthesizes to
Terraform JSON (cdktf.out/)
```

## Code Organization

### Core DSL Files
- `src/Core/Nelknet.Cdktf.Core/Core.fs` - Stack context and main computation expression
- `src/Core/Nelknet.Cdktf.Core/TerraformOutputs.fs` - Output builder
- `src/Providers/<Provider>/Generated/...` - Generated provider DSL (Hetzner today, others later)

### Generated Code
- `generated/<provider>/` - C# provider bindings from `cdktf provider add` (ignored in git, regenerated by the build)
- `src/Providers/<Provider>/Generated/...` - Fabulous.AST output (regenerated automatically; ignored in git)

### Important Configuration
- `cdktf.json` - CDKTF app configuration, points to the examples project
- `Directory.Packages.props` - Central package versions (CDKTF 0.21.0, JSII 1.112.0)
- Solution targets .NET 8.0 throughout

## Development Guidelines

### When Adding New Providers
1. Run `cdktf provider add <publisher/name>@=<version> --language csharp --force-local` to update `cdktf.json` and download bindings.
2. Scaffold any missing provider projects with `dotnet fsi tools/scaffold-providers.fsx`.
3. Add the new `.fsproj` (and optionally `generated/<id>/<id>.csproj`) to `Nelknet.Cdktf.slnx`.
4. Regenerate bindings with `dotnet build -p:ForceCodeGen=true`.
5. Commit only the handcrafted pieces (`cdktf.json`, the new `.fsproj`, docs). Generated files remain ignored.

### Code Generation Strategy
- Using Fabulous.AST (not Myriad) for a simple build pipeline.
- Generator lives in `tools/Nelknet.Cdktf.CodeGen/` and accepts command-line arguments.
- Provider projects import `build/CodeGen.targets`, which runs the generator before build when needed.
- Generated code stays out of source control; regenerate as needed with `dotnet build -p:ForceCodeGen=true`.

### Testing Approach
- No automated tests yet - validate via `cdktf synth` and manual inspection
- Always run `dotnet build` before commits
- Check synthesized JSON in `cdktf.out/` matches expectations
- Never commit `cdktf.out/` or secrets

## Important Notes

- `source_code_references/Pulumi.FSharp.Extensions/` is read-only reference material
- The `cdktf.out/` directory is ephemeral - exclude from commits
- Environment variable `HCLOUD_TOKEN` required for Hetzner operations
- Generated C# projects use JSII for TypeScript interop - do not modify JSII metadata
